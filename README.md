{% include mathjax.html %}
### This is the homepage for the public summary of my MPhys project, Fourier accelerated lattice field theory.

This public summary is aimed at those people who have completed Higher (or equivalent) level physics and like to read the science section of their favourite news website.

Our current understanding of how fundamental particles interaction in our universe envisions them as being little excitations in "quantum fields" which permeate space and time. The figure below shows an impression of a field with several peaks (excitations) localized in space. These peaks can be thought of as particles which can interact with each other (sometimes violently).  
![image](https://user-images.githubusercontent.com/26764889/78590373-a5e5ef00-7839-11ea-82ea-e6295d1d22be.png)

<!--![image](https://user-images.githubusercontent.com/26764889/78572038-dc624080-781e-11ea-9780-61a126b615f8.png)-->


<!--![image](https://user-images.githubusercontent.com/26764889/78559293-0f4f0900-780c-11ea-9d3a-51cda3c59ae2.png)-->

There are two main ways to study these fields theoretically in order to investigate properties of these particles:
1. Blackboard calculations involving Feynman diagrams.
2. Simulate the fields on a computer (lattice field theory).

My project looked at the 2nd of these approaches which is particularly useful in certain cases (such as in the theory of _quantum chromodynamics_ which describes the physics of quarks, the constituents of protons and neutrons).

In order to get an idea of how we carry out lattice field simulations on a computer, let us first look at simulating something that can be visualized a little easier. Thus, we turn our attention to the quantum mechanical harmonic oscillator. This is nothing much more than a system which will be quite familiar: a mass attached to a spring and allowed to oscillate back and forth. The quantum mechanics bit just means that the mass-spring system won't act quite as it is expected to in everyday life. 

Now, suppose you were to set up a frictionless table, and place on top of such a contraption consisting of a weight connected to a wall via a spring. You pull the mass away from its equilibrium point where it was stationary and let go. What you see is the motion below:

![classical_final](https://user-images.githubusercontent.com/26764889/78579416-cd808b80-7828-11ea-942f-05630130c676.gif)

If you pull the mass back the same distance and let go, you will observe the exact same motion every time.

Now, in the case of a quantum mechanical version of this harmonic oscillator, we find that the motion can be quite different. In fact, each time you watch the oscillator move in time, you will see it do something slightly different. This is because in quantum mechanics, a particle's position is a probabilistic thing - there is some porbability that at time t after you let go of the mass that it is at position A. However, there is also some probability that it is at position B. Only when you measure its position can you say for certain where the mass is.

As a consequence, there are infinitely many ways that the mass could have oscillated about on its spring (referred to as _paths_) in the quantum mechanical case. Albeit, some of these are more likely to be realized than others.

So how does all of this relate to our computer simulations? Well, it turns out that everything we may want to know about our quantum mass on a spring system is encoded in a mathematical object called the **path integral**. And without going into too much detail, this path integral is simply a sum of all those paths we talked about. Each of these paths are assigned a _weight_ - some probability that the path in question is that which the system follows. To simply add up all of these paths in a naive approach would be a lot of work (an infinite amount actually). Instead we use computational methods, called **Markov chain Monte Carlo** (MCMC) methods, to efficiently sum up these paths by choosing to look at paths with a greater probabilistic weight more often. This is termed importance sampling.

The image below shows a few partial paths generated by an MCMC algorithm.
![image](https://user-images.githubusercontent.com/26764889/78587748-50a7de80-7835-11ea-846f-9a2e885e6ab9.png)

And these correspond to different motions of our quantum mechanical harmonic oscillator as shown in the animation below (shortened and sped up for visualisation). The motion seems jittery but this is exactly what is expected in light of quantum mechanics probabilistic nature.

![qmho](https://user-images.githubusercontent.com/26764889/78593291-4e964d80-783e-11ea-936d-f203f04d8e1a.gif){:height="30%" width="30%"



The particular paths traced out in the plot above were generated with a certain variant of MCMC called Hamiltonian Monte Carlo (HMC). This algorithm has a few steps which we briefly summarize here:
1. Guess some initial path (path #1) for the system (it's not too important what it is but the more reasonable the faster HMC runs). This initial guess could be the green path above. We see why the term "lattice" is used as we set up a lattice of time increments (the horizontal lines) and associate with each one an x position.

2.Generate a momentum p<sub>n</sub> for each lattice point. The momentum is chosen from a Gaussian probability distribution, which means that the probability of picking p<sub>n</sub> so that it equals p<sub>n</sub> &plusmn; dp$ is proportional to e<sup>(-)</sup>.

3. Update the path to a _final_ path via Hamiltonian dynamics. What this basically means is use the familiar Newtonian equations of motion to see what the  x<sub>n</sub> positions are at a later time.

4. Now we choose to make this path our next path, path #2, only with some probability min(1,e <sup>-(H <sub>new</sub> - H <sub>old</sub>)</sup>









**Bold** and _Italic_ and `Code` text

[Link](url) and
 

