{% include mathjax.html %}
### This is the homepage for the public summary of my MPhys project, Fourier accelerated lattice field theory.

This public summary is aimed at those people who have completed Higher (or equivalent) level physics and like to read the science section of their favourite news website.

Our current understanding of how fundamental particles interaction in our universe envisions them as being little excitations in "quantum fields" which permeate space and time. The figure below shows an impression of a field with several peaks (excitations) localized in space. These peaks can be thought of as particles which can interact with each other (sometimes violently).  
![image](https://user-images.githubusercontent.com/26764889/78590373-a5e5ef00-7839-11ea-82ea-e6295d1d22be.png)

<!--![image](https://user-images.githubusercontent.com/26764889/78572038-dc624080-781e-11ea-9780-61a126b615f8.png)-->


<!--![image](https://user-images.githubusercontent.com/26764889/78559293-0f4f0900-780c-11ea-9d3a-51cda3c59ae2.png)-->

There are two main ways to study these fields theoretically in order to investigate properties of these particles:
1. Blackboard calculations involving Feynman diagrams.
2. Simulate the fields on a computer (lattice field theory).

My project looked at the 2nd of these approaches which is particularly useful in certain cases (such as in the theory of _quantum chromodynamics_ which describes the physics of quarks, the constituents of protons and neutrons).

In order to get an idea of how we carry out lattice field simulations on a computer, let us first look at simulating something that can be visualized a little easier. Thus, we turn our attention to the quantum mechanical harmonic oscillator. This is nothing much more than a system which will be quite familiar: a mass attached to a spring and allowed to oscillate back and forth. The quantum mechanics bit just means that the mass-spring system won't act quite as it is expected to in everyday life. 

Now, suppose you were to set up a frictionless table, and place on top of such a contraption consisting of a weight connected to a wall via a spring. You pull the mass away from its equilibrium point where it was stationary and let go. What you see is the motion below:

![classical_final](https://user-images.githubusercontent.com/26764889/78579416-cd808b80-7828-11ea-942f-05630130c676.gif)

If you pull the mass back the same distance and let go, you will observe the exact same motion every time.

Now, in the case of a quantum mechanical version of this harmonic oscillator, we find that the motion can be quite different. In fact, each time you watch the oscillator move in time, you will see it do something slightly different. This is because in quantum mechanics, a particle's position is a probabilistic thing - there is some porbability that at time t after you let go of the mass that it is at position A. However, there is also some probability that it is at position B. Only when you measure its position can you say for certain where the mass is.

As a consequence, there are infinitely many ways that the mass could have oscillated about on its spring (referred to as _paths_) in the quantum mechanical case. Albeit, some of these are more likely to be realized than others.

So how does all of this relate to our computer simulations? Well, it turns out that everything we may want to know about our quantum mass on a spring system is encoded in a mathematical object called the **path integral**. And without going into too much detail, this path integral is simply a sum of all those paths we talked about. Each of these paths are assigned a _weight_ - some probability that the path in question is that which the system follows. To simply add up all of these paths in a naive approach would be a lot of work (an infinite amount actually). Instead we use computational methods, called **Markov chain Monte Carlo** (MCMC) methods, to efficiently sum up these paths by choosing to look at paths with a greater probabilistic weight more often. This is termed importance sampling.

The image below shows a few partial paths generated by an MCMC algorithm.
![image](https://user-images.githubusercontent.com/26764889/78587748-50a7de80-7835-11ea-846f-9a2e885e6ab9.png)

And these correspond to different motions of our quantum mechanical harmonic oscillator as shown in the animation below (shortened and sped up for visualisation). The motion seems jittery but this is exactly what is expected in light of quantum mechanics probabilistic nature.

<img src="https://user-images.githubusercontent.com/26764889/78593291-4e964d80-783e-11ea-936d-f203f04d8e1a.gif" height="40%" width="40%">



The particular paths traced out in the plot above were generated with a certain variant of MCMC called Hamiltonian Monte Carlo (HMC). This algorithm has a few steps which we briefly summarize here:
<p style="text-align: center;">  
<li> Guess some initial path (path #1) for the system (it's not too important what it is but the more reasonable the faster HMC runs). This initial guess could be the green path above. We see why the term "lattice" is used as we set up a lattice of time increments (the horizontal lines) and associate with each one an x position.</li>

<li> Generate a momentum p<sub>n</sub> for each lattice point. The momentum is chosen with a [Gaussian probability](https://en.wikipedia.org/wiki/Normal_distribution?oldformat=true).</li>

<li> Update the path to a _final_ path via Hamiltonian dynamics. What this basically means is use the familiar equations <img src="https://latex.codecogs.com/gif.latex?F%3Dma"> and distance = speed x time to find what the positions are at a later time</li>

<li>Now we choose to make this path our next path, path #2, only with some probability <img src="https://latex.codecogs.com/gif.latex?%5Cmin%281%2C%5Cexp%28-%28H_%7B%5Ctext%7Bnew%7D%7D-H_%7B%5Ctext%7Bold%7D%7D%29%29">. This particular choice is made so that we end up generating paths according to their probabilistic weighting as we mentioned before</li>

<li>Steps 2-4 are repeated as many times as desired (the more times, the more accurate our results)</li>
</p>
HMC is very effective and gives accurate reslts for many applications in lattice field theory and beyond.
One place where it struggles a bit however is when we try and make our lattice finer and finer so that there is little distance between successive lattice points. This is referred to as "going to the continuum limit". When we try and do that, the paths we generate tend to become very similar to the ones which came just before them in our chain of paths (they are highly autocorrelated). This leads to our results having a lot of associated error. 

One way to combat this is named Fourier acceleration and a focus of my project. How Fourier acceleration goes about alleviating the issue of autocorrelated data is by changing how we do the Hamiltonian dynamics step of HMC (step 3). In particular, it ensures that the physics happening at long length scales (kind of like communication between the lattice points at the far left and right edges of the lattice) occurs just as fast as the physics at short length scales (communication between adjacent lattice points). If we don't Fourier accelerate, we find that the long range physics takes much longer to occur and acts like a bottlenck on the simulations, causing lots of autocorrelation and therefore requiring longer simulation time. Below gives a comparison of a few paths produced by unaccelerated (left) and accelerated HMC (right). We can see that without Fourier acceleration, the trio of successive paths are quite similar. However, once we accelerate, the paths look much more independent of each other.

Standard HMC             |  Fourier accelerated HMC
:-------------------------:|:-------------------------:
<img src="https://user-images.githubusercontent.com/26764889/78605443-6e843c00-7853-11ea-9eda-b19b18645559.png"> |    <img src="https://user-images.githubusercontent.com/26764889/78605397-57454e80-7853-11ea-9851-89f7e20aacd2.png">

 
The physical systems to which I applied Fourier accelerated HMC in my project were free scalar field theory and interacting &phi;<sup>4</sup> fields. The only real difference between doing simulations for these fields and doing simulations of our quantum mechanical system is that for fields rather than generating a whole bunch of paths a particle can take through space and time, we instead generate a whole bunch of field configurations.  The hope is that by using this Fourier acceleration technique 









**Bold** and _Italic_ and `Code` text

[Link](url) and
 

